# AI Parallel Ops

Claude Code、Google Gemini（画像生成: Nano Banana等）など複数のAIツールを並列稼働させ、監督（ディレクター）として仕事を進めるためのワークフロー定義。

## コンセプト

- 自分は手を動かさない。複数のAIツールに委任し、判断とレビューに集中する
- 複数タスクを同時進行する（例: 4並列）
- AIは自律的に動き、判断に迷った場合のみエスカレーションしてくる

## 私の役割: 監督（ディレクター）

- 自分で手を動かすのではなく、複数のAIツール/エージェントに仕事を委任する
- AIは自律的に動く。判断に迷いエスカレーションしてきた問題に対してのみ介入する
- 成果物のレビューと最終判断を行う
- 同時稼働数は状況に応じて拡張可能（例: 4並列）

## 日々の仕事の流れ（例: 4並列）

### 0. ゴール定義: 何を達成するか決める
- 今日/今回のセッションで達成したいゴールを明文化する
- ゴールが曖昧だとTODOがブレる。ここが全ての起点

```
例: 「プロダクト紹介のWebページとプレゼン資料を完成させる」
```

### 1. 成果物の定義: 何ができたら完了か
- 各タスクの完了条件を決める
- これがないとAIが止め時を判断できず、レビューの基準もない

```
例:
  - Webページ → index.html が動作しデプロイ可能な状態
  - シナリオ → Markdown形式、5章構成、各章300字以上
  - 画像素材 → 各シーン用に5枚、1024x1024、PNG
  - スライド → Markdown形式、15ページ構成
```

### 2. 共通ルールの整備
- トーン、命名規則、ディレクトリ構成など、全タスクに共通するルールを整理する
- CLAUDE.mdや共有ドキュメントに書いておけば、毎回指示に含める必要がない

### 3. TODO整理: 作業一覧を洗い出す
- ゴールと成果物の定義から、必要な作業を全て洗い出す
- この一覧が監督としての全体把握の地図になる
- 各AIへの指示が「TODO #3をやれ」で済むようになる

### 4. 依存関係の整理
並列度を最大化するために、TODOを2種類に分ける:

- **独立タスク**: 他の成果物を待たずに着手できる
- **依存タスク**: 先行タスクの成果物が必要

```
例:
  [独立] コード実装
  [独立] 画像素材生成
  [独立] シナリオ骨子作成
  [依存] スライド作成 ← シナリオ骨子 + 画像素材が必要
```

> **段取り（0〜4）が並列実行の効率を決める。段取り8割、実行2割。**

### 5. 一斉投入: 独立タスクを同時に全部起動する
独立タスクは待つ理由がない。一気に起動する。

1. ターミナル/ブラウザを必要数開く
2. **全ウィンドウに指示を貼り付けてから、順にEnterを押す**（1つ起動を見届けてから次、ではない）
3. 各タスクに渡すもの:
   - ゴールと成果物の定義
   - 参照すべきファイルパス
   - 制約条件（トーン、ルール等）
   - 「判断に迷ったら聞け。それ以外は自分で進めろ」
4. ツールの割り当て:
   - コード生成・シナリオ生成・スライド生成 → Claude Code
   - 画像生成 → Google Gemini (Nano Banana等)

### 6. 監督: 巡回しながらエスカレーション対応
- 全AIが同時に自律稼働している状態を維持する
- **巡回パターン**: 端末を定期的に切り替えて進捗を目視確認
- エスカレーション（質問）が来ていたら即判断して再開させる
- **スロットが空いたら即補充**: 1つ完了 or 待ちになったら、次のタスクを投入して並列数を維持する
- 質問が来ない＝順調。放置でいい

### 7. 依存タスクの即時投入
- 先行タスクが完了したら、その成果物のパスを渡して依存タスクを即起動
- 空いたスロットに詰め込み、常に並列数を埋める

```
時間軸 →
スロット1: [コード実装---------]  [次のタスク----]
スロット2: [画像素材生成---]  [スライド作成（依存解消）---]
スロット3: [シナリオ骨子---]  [別タスク--------]
スロット4: [調査タスク--]  [別タスク--]  [別タスク--]
```

## 稼働率を落とさないためのルール

並列の意味がなくなる最大の原因は「自分だけが動いていてAIが遊んでいる」状態。これを防ぐ。

### アンチパターン: こうなったら負け

| 状態 | 原因 | 対策 |
|------|------|------|
| 自分だけが作業している | AIへの指示作成に時間をかけすぎ | 指示テンプレートを事前に用意する。完璧な指示より早い投入 |
| 1〜2スロットしか埋まっていない | 投入するタスクが思いつかない | 段取りフェーズ（0〜4）でTODOを十分に洗い出しておく |
| AIが全員止まって待っている | エスカレーション対応が遅い | 巡回頻度を上げる。判断を即断する。迷ったら「とりあえずこれで進めろ」 |
| 完了したのにスロットが空いたまま | 次に何を投入すべきかわからない | TODOリストに優先順位をつけておく。次の投入候補を常に把握 |
| レビューに時間を取られてスロットが埋まらない | レビューと投入を直列にやっている | 先に次タスクを投入してからレビューする |

### 原則: 自分が手を止めるな、ではなく「AIを止めるな」

- **投入 > レビュー**: 成果物のレビューより、空きスロットへの投入を優先する
- **即断即決**: エスカレーションへの回答に悩むなら、仮の方針で進めさせて後で修正
- **指示は雑でいい**: 完璧な指示を練るより、70%の指示で早く投入し、途中で軌道修正
- **段取りで勝負をつける**: 実行フェーズで迷わないために、段取りフェーズでTODOと優先順位を固めておく

### 8. レビュー・承認
- 完了した成果物から順にレビューする
- 修正指示 → 同じスロットで再実行
- 承認 → スロットを解放して次のタスクへ

## 運用原則（経営・軍事・製造業の知見から）

### 指示の出し方: 意図を伝えよ、手順を伝えるな

**ミッションコマンド（独: Auftragstaktik / NATO軍事ドクトリン）** から。部下には「何を達成するか」と「なぜそれが必要か」を伝え、「どうやるか」は任せる。AIへの指示も同じ。

- 各タスクには **Commander's Intent（指揮官の意図）** を含める
- やるべきことだけでなく、**やってはいけないこと**の境界も明示する
- 詳細な手順指定は、AIが不慣れな領域のタスクに限定する

**タスク習熟度で指示の粒度を変える（Andy Grove『High Output Management』）:**

| AIの習熟度 | 指示の粒度 | 例 |
|-----------|-----------|-----|
| 高（定型作業） | ゴールだけ伝える | 「このAPIにCRUDエンドポイントを追加」 |
| 中 | ゴール＋制約＋参考ファイル | 「認証機能を追加。既存のauth.tsのパターンに合わせろ」 |
| 低（複雑・初見） | ゴール＋制約＋手順＋中間チェックポイント | 「まず設計案を出せ。承認後に実装に入れ」 |

### 監督のレバレッジ: 何に時間を使うかが全てを決める

**マネージャーのレバレッジ（Andy Grove『High Output Management』）** から。監督の生産性 ＝ 全AIの総出力 / 監督が使った時間。

- **最高レバレッジ**: 事前の指示設計。5分の明確な指示で、2時間のAI迷走を防ぐ
- **高レバレッジ**: 並列タスク間のインターフェース定義。ここだけは監督自身が決める
- **低レバレッジ**: 完了済み成果物の細かいレビュー → 後回しにしてスロット投入を優先

### ボトルネック理論: 自分が詰まりポイントだと自覚する

**制約理論（Goldratt『ザ・ゴール』）** から。システム全体のスループットはボトルネック1箇所で決まる。AIをいくら増やしても、監督の処理速度が上限になる。

- **ボトルネック（＝自分）を遊ばせるな**: 常に次の投入候補を手元に用意しておく
- **ボトルネックの前にバッファを置け**: 指示テンプレートを事前作成し、投入をゼロ秒で行える状態にする
- **ボトルネック以外の最適化は幻想**: AIの応答速度を気にするより、自分のレビュー・判断速度を上げる

### ラインを止めるな、ただし不良品は即止める

**トヨタ生産方式（アンドン・コード）** から。問題を検知したら即座にラインを止める。不良品が下流に流れるコストの方が大きい。

- **複雑なタスクは「計画 → 承認 → 実行」の2段階にする**: AIにまず計画だけ出させ、60秒で確認してから実行させる
- **間違った方向に30分走らせるより、即殺して再投入**: 途中修正より再起動の方が速い場合が多い
- **ただし順調なAIは絶対に止めるな**: 不必要な中間チェックは並列効率を殺す

### WIP制限: 並列数には自分の処理能力で上限がある

**カンバン / リーン生産方式** から。仕掛り（WIP）を増やしすぎるとスループットが落ちる（リトルの法則）。

- **自分がコンテキストを保持できる数が真の上限**: 端末を切り替えた時に「これ何だっけ」となったら超過
- **まず3並列から始めて、レビューに余裕があれば増やす**
- 目安: WIP上限 ＝ 自分のレビュー処理速度/時 × タスク平均所要時間

### 標準化: 指示テンプレートで投入速度を上げる

**トヨタ生産方式（標準作業）** から。全ての作業を標準化すれば、品質が安定し、問題が逸脱として即座に見える。

タスク投入テンプレート:
```
## 意図（なぜやるか）
[プロジェクト全体の目的と、このタスクの位置づけ]

## 目的（何を達成するか）
[1文で]

## 成果物と完了条件
[具体的、検証可能な条件]

## 制約（やってはいけないこと）
[境界の明示]

## 参照ファイル
[必要なパス一覧]

## エスカレーション基準
判断に迷ったら聞け。それ以外は自分で進めろ。
```

### ファイルスコープの分離: 同じファイルを触るなら直列にしろ

**アジャイルのストーリー分割** から。並列タスクは薄い縦割りスライスにする。

- **2つのAIが同じファイルを触る＝並列不可、直列にする**
- 並列化の鍵は **インターフェースの事前定義**: 監督がモジュール間の境界を決めれば、各AIは独立して動ける
- これが監督の最高レバレッジ活動

### 主攻（Schwerpunkt）: 全てのリソースを集中すべきポイントを決める

**ドイツ軍事ドクトリン** から。常に1つの主攻方向を定め、他は支援に回す。

- 並列タスクの中で1つを **主攻（クリティカルパス）** に指定する
- 主攻タスクのレビューを最優先。競合が起きたら主攻が勝つ
- 他のタスクは主攻を支援するか、主攻と干渉しない独立領域で動く

## 並列の使い分け

| 状況 | 方式 |
|------|------|
| 別々のプロジェクト・別々の成果物 | 独立した別ウィンドウ/タブで別AIツールを起動 |
| 同一プロジェクト内の並列作業（Claude Code） | 1つのClaude内でサブエージェントを使う |

## AIツール間の連携

- ファイルシステム経由で行う
- Claude Aの成果物を Claude Bに参照させたい場合、ファイルパスを指示に含める
- 依存関係があるタスクは先行タスク完了後に投入する

## 作業ディレクトリの原則

- 各Claudeの作業ディレクトリは分ける（衝突防止）
- 共通ルールはCLAUDE.mdに書いておく（毎回指示不要にする）

## 参考文献

- Andy Grove『High Output Management』— タスク習熟度、マネージャーのレバレッジ
- Peter Drucker『The Effective Executive』— 集中、貢献への焦点
- Eliyahu Goldratt『ザ・ゴール』— 制約理論、ボトルネック管理
- トヨタ生産方式 — アンドン・コード、標準作業、カンバン、WIP制限
- NATO Mission Command / Auftragstaktik — 意図の伝達、自律行動
- ドイツ軍事ドクトリン — Schwerpunkt（主攻）、FRAGOs（断片命令）
- アジャイル/スクラム — ストーリー分割、Definition of Done、タイムボックス
